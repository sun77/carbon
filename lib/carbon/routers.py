import imp
from carbon.relayrules import loadRelayRules
from carbon.hashing import ConsistentHashRing
import re


class DatapointRouter:
  "Interface for datapoint routing logic implementations"

  def addDestination(self, destination):
    "destination is a (host, port, instance) triple"

  def removeDestination(self, destination):
    "destination is a (host, port, instance) triple"

  def getDestinations(self, key):
    """Generate the destinations where the given routing key should map to. Only
    destinations which are configured (addDestination has been called for it)
    may be generated by this method."""


class RelayRulesRouter(DatapointRouter):
  def __init__(self, rules_path):
    self.rules_path = rules_path
    self.rules = loadRelayRules(rules_path)
    self.destinations = set()

  def addDestination(self, destination):
    self.destinations.add(destination)

  def removeDestination(self, destination):
    self.destinations.discard(destination)

  def getDestinations(self, key):
    for rule in self.rules:
      if rule.matches(key):
        for destination in rule.destinations:
          if destination in self.destinations:
            yield destination
        if not rule.continue_matching:
          return


class ConsistentHashingRouter(DatapointRouter):
  def __init__(self, replication_factor=1):
    self.replication_factor = int(replication_factor)
    self.instance_ports = {} # { (server, instance) : port }
    self.ring = ConsistentHashRing([])

    # Temporary hack to drop some offensive metrics
    self.drop_re = re.compile('.*\.TimeBucket\..*')
    self.drop_re2 = re.compile('.*\.Data\..*')

    #Second temporary hack to avoid agglo on some case where not appropriate
    self.no_agglo = re.compile('^criteo\.cas\.counter\.sum\.displays\..*')

  def addDestination(self, destination):
    (server, port, instance) = destination
    if (server, instance) in self.instance_ports:
      raise Exception("destination instance (%s, %s) already configured" % (server, instance))
    self.instance_ports[ (server, instance) ] = port
    self.ring.add_node( (server, instance) )

  def removeDestination(self, destination):
    (server, port, instance) = destination
    if (server, instance) not in self.instance_ports:
      raise Exception("destination instance (%s, %s) not configured" % (server, instance))
    del self.instance_ports[ (server, instance) ]
    self.ring.remove_node( (server, instance) )

  def getDestinations(self, metric):

    if self.drop_re.match(metric):
        return
    if self.drop_re2.match(metric):
        return

    key = self.getKey(metric)

    for count,node in enumerate(self.ring.get_nodes(key)):
      if count == self.replication_factor:
        return
      (server, instance) = node
      port = self.instance_ports[ (server, instance) ]
      yield (server, port, instance)

  #def getKey(self, metric):
  #  return metric

  def getKey(self, metric):
    if self.no_agglo.match(metric):
        return metric
    #RBA: modification done to ensure that all the metrics to be aggregated are processed by the same aggregator
    return metric.rsplit('.',1)[0]

  def setKeyFunction(self, func):
    self.getKey = func

  def setKeyFunctionFromModule(self, keyfunc_spec):
    module_path, func_name = keyfunc_spec.rsplit(':', 1)
    module_file = open(module_path, 'U')
    description = ('.py', 'U', imp.PY_SOURCE)
    module = imp.load_module('keyfunc_module', module_file, module_path, description)
    keyfunc = getattr(module, func_name)
    self.setKeyFunction(keyfunc)
